import os

print('当前脚本的进程', os.getpid())   # 34881

# 这个函数你就没觉的奇怪吗？ 是什么调用法？ 可以理解fork的时候就赋值了2份代码，不同代码返回的结果不一样。我脚本中的代码会在2个两个地方同时执行。
pid = os.fork()
# pid返回这个步骤，在两个进程中都会执行
# pid返回的逻辑基本是这样，if os.getpid == 暂存的父进程id : pid != 0  else: pid = 0
# pid变量会同时保存在2份进程代码上，pid 就是processid的逻辑处理的结果，判断pid,就相当于判断 进程id !!!

# pid就是变相的进程id, 就是用来判断我是谁？ 哦，我的名字是小明，我就执行这一块代码？我的名字是小红，我就这些那一块代码？
if pid == 0:       # 注意pid变量是在2分代码中都有了； 判断pid就相当于判断当前进程ID
    print('子进程代码单独做的事情 pid==0: {}'.format(os.getpid()))         # 34882
    # 创建一个子进程执行任务，就是加上进程判断条件，在这块代码块里面执行任务
else:
    print('父进程有单独的代码吗 pid!=0:{}'.format(os.getpid()))     # 34881

print('第二次fork, 这一块代码是谁在执行？{}'.format(os.getpid()))    # 34881  34882

# 再存一个变量，联合pid就可以判断
ppid = os.fork()    # 前面的2个进程都会执行fork, 在赋值ppid，是4个进程搜会赋值
if ppid == 0:
    print('我是第二次fork pid==0，我会执行几次:{}'.format(os.getpid()))             # 34883 34884
else:
    print('我是第二次fork pid!=0，我会执行几次:{}'.format(os.getpid())) # 34881 34882

print('我是第二次。。。，我会执行几次:{}'.format(os.getpid())) # 34881  34883  34882  34884

# 如何控制不同线程做不同的事情，只要通过pid判断，因为在编码的时候事先不知道线程号，所以需要根据暂存父进程id和当前进程比较来封装一下
if pid != 0 and ppid != 0:
    print('原始父进程：{}'.format(os.getpid()))
if pid != 0 and ppid == 0:
    print('原始父进程第二次创建的 子进程2:{}'.format(os.getpid()))
if pid == 0 and ppid != 0:
    print('原始父进程第一次创建的 子进程1:{}'.format(os.getpid()))
if pid == 0 and ppid == 0:
    print('子进程1创建的子进程3:{}'.format(os.getpid()))


# 当前操作系统的核心数 8
# 当前脚本的进程 34881
# 父进程有单独的代码吗 pid!=0:34881
# 第二次fork, 这一块代码是谁在执行？34881
# 我是第二次fork pid!=0，我会执行几次:34881
# 我是第二次。。。，我会执行几次:34881
# 子进程代码单独做的事情 pid==0: 34882
# 第二次fork, 这一块代码是谁在执行？34882
# 我是第二次fork pid==0，我会执行几次:34883
# 我是第二次。。。，我会执行几次:34883
# 我是第二次fork pid!=0，我会执行几次:34882
# 我是第二次。。。，我会执行几次:34882
# 我是第二次fork pid==0，我会执行几次:34884
# 我是第二次。。。，我会执行几次:34884
#
# |
# |  -> 81
# |
# |\
# | \  -> 82
# |  \
# |   \
# |    \
# |     \
# |      \
# |       \
# |        \
# |  81     \  82
# |\        |\
# | \  83   | \  84
# |  \      |  \
# |  |      |   |
# |  |      |   |